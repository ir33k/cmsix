<?php

/** Database text file with texts data. */
define('CMSIX_TEXT_FILE', 'db.txt');

/** Directory that holds all CMS files uploaded by user. */
define('CMSIX_FILES_DIR',  'files/');

/** Different sizes of images that are uploaded in admin panel. */
define('CMSIX_SIZES', [2048, 720, 320]);

/** Unique string that is used for files generated by CMSIX.
 * Currently only for images that are optimized to different CMSIX_SIZES. */
define('CMSIX_FILE_PREFIX', '_cmsix_');

/** Unique string places in front of every key in database text file. */
define('CMSIX_TEXT_SEPARATOR', '============================================================');

// TODO(irek): There must be a better way.
/** URL path to directory with CMSIX cms files. */
define('CMSIX_URL_ROOT', $_SERVER['DOCUMENT_ROOT'] == __DIR__ ? "/" : str_replace($_SERVER['DOCUMENT_ROOT'], '', __DIR__));

/** Absolute URL to directory with cms files. */
define('CMSIX_URL_FILE', CMSIX_URL_ROOT.'/'.CMSIX_FILES_DIR);

/** Absolute server path to directory with cms files. */
define('CMSIX_PATH_TEXT', __DIR__.'/'.CMSIX_TEXT_FILE);

/** Absolute server path to database text file with texts data. */
define('CMSIX_PATH_FILE', __DIR__.'/'.CMSIX_FILES_DIR);

/** Read database text file in key value fashion. */
function cmsix_read(): array
{
	$res = [];
	if (!is_resource($file = fopen(CMSIX_PATH_TEXT, 'rb'))) {
		return $res;
	}
	while ($line = fgets($file)) {
		if (str_starts_with($line, CMSIX_TEXT_SEPARATOR)) {
			$line = fgets($file);
		}
		$key = trim($line);
		$res[$key] = '';
		while (($line = fgets($file)) and
		       !str_starts_with($line, CMSIX_TEXT_SEPARATOR)) {
			$res[$key] .= $line;
		}
		$res[$key] = rtrim($res[$key]);
	}
	fclose($file);
	ksort($res);
	return $res;
}

/** Split $str into non empty lines. */
function cmsix_lines(string $str): array
{
	$res = explode("\n", $str);
	return array_filter($res);
}

/** Filter $arr array by keys using $pattern. */
function cmsix_get(array $arr, string $pattern): array
{
	return array_filter(
		$arr,
		fn($key) => preg_match($pattern, $key),
		ARRAY_FILTER_USE_KEY
	);
}

/** Make HTML $tag string with $child and $attr attributes. */
function cmsix_tag(string $tag, ?string $child = null, ?array $attr = []): string
{
	$attr_str = '';
	foreach ($attr as $k => $v) {
		$attr_str .= "{$k}=\"{$v}\" ";
	}
	return "<{$tag} {$attr_str} " . ($child ? ">{$child}</{$tag}>" : "/>");
}

/** Make img tag with $file and $attr attributes, try "srcset" and "sizes". */
function cmsix_img(string $file, ?array $attr = []): string
{
	$attr['src'] = CMSIX_URL_FILE.$file;
	$attr['loading'] ??= 'lazy';            // Default "loading"
	// If "srcset" attibute is not defined by hand in $attr then
	// check if file has internal files (with CMSIX_FILE_PREFIX) of different
	// sizes (CMSIX_SIZES).  If yes then define "srcset" and "sizes".
	if (!isset($attr['srcset'])) {
		$srcset = [];
		foreach (CMSIX_SIZES as $size) {
			$path = $file.CMSIX_FILE_PREFIX.$size;
			$ext  = pathinfo($file)['extension'];
			if ($ext) {
				$path .= ".{$ext}";
			}
			if (file_exists(CMSIX_PATH_FILE.$path)) {
				$path = CMSIX_URL_FILE.$path;
				array_push($srcset, "{$path} {$size}w");
			}
		}
		if (count($srcset)) {
			// Use original image when possible.
			if (extension_loaded('gd')) {
				[$size] = getimagesize(CMSIX_PATH_FILE.$file);
				$path = CMSIX_URL_FILE.$file;
				array_unshift($srcset, "{$path} {$size}w");
			}
			$attr['srcset'] = implode(', ', $srcset);
		}
	}
	if (isset($attr['srcset'])) {           // Only when "srcset"
		$attr['sizes'] ??= '100vw';     // Default "sizes"
	} else {
		unset($attr['sizes']);
	}
	return cmsix_tag('img', null, $attr);
}

/** Parse Markdown $str to HTML.  This is not a full implementation.
 * Covers only simplest cases from original Markdown design:
 * https://daringfireball.net/projects/markdown/syntax */
function cmsix_md(string $str): string
{
	$res   = '';                            // HTML string
	$prev  = null;                          // Previous HTML tag
	$next  = null;                          // Next HTML tag
	foreach (explode("\n", $str) as $v) {	// Go line by line
		if ($prev == 'pre') {           // pre takes priority
			if (preg_match("/^```$/", $v)) {
				$res .= "</{$prev}>\n";
				$prev = null;
				continue;       // Close pre tag
			}
			$res .= $v."\n";
			continue;
		}
		if (trim($v) == '') {           // Skip empty lines.
			continue;
		}
		/**/ if (preg_match('/^```/',      $v)) $next = 'pre';
		else if (preg_match('/^-{5,}-*$/', $v)) $next = 'hr';
		else if (preg_match('/^#/',        $v)) $next = 'h';
		else if (preg_match('/^[-*+]\s/',  $v)) $next = 'ul';
		else if (preg_match('/^[0-9+]\./', $v)) $next = 'ol';
		else if (preg_match('/^>/',        $v)) $next = 'blockquote';
		else /* Paragraph is the default tag */ $next = 'p';
		if ($next != $prev) {
			if (isset($prev)) {
				$res .= "</{$prev}>\n";
			}
			if ($next == 'hr' || $next == 'h') {
				$prev = null;
			} else {
				$prev = $next;
				$res .= "<{$prev}>\n";
			}
		}
		if ($next == 'pre') {           // pre takes priority
			$v = preg_replace('/^```/', '', $v);
			if (strlen($v)) {
				$res .= $v."\n";
			}
			continue;
		}
		// Apply inline tags used in all other block tags.
		$v = preg_replace('/\[([^\[]+)\]\(([^\)]+)\)/', '<a href="\2">\1</a>', $v);
		$v = preg_replace('/(\*\*|__)(.*?)\1/', '<strong>\2</strong>', $v);
		$v = preg_replace('/\~\~(.*?)\~\~/', '<del>\1</del>', $v);
		$v = preg_replace('/(\*|_)(.*?)\1/', '<em>\2</em>', $v);
		$v = preg_replace('/`(.*?)`/', '<code>\1</code>', $v);
		$v = preg_replace('/(.*?)  $/', '\1<br/>', $v);
		switch ($next) {
		case 'hr':
			$res .= '<hr/>';
			break;
		case 'h':
			$res .= preg_replace_callback('/(#+)(.*)/', function ($regs) {
				$level = strlen($regs[1]);
				return sprintf('<h%d>%s</h%d>', $level, trim($regs[2]), $level);
			}, $v);
			break;
		case 'ul':
		case 'ol':
			$res .= "\t<li>".trim(preg_replace('/^([-\*\+]|[0-9]+.)/', '', $v)).'</li>';
			break;
		case 'blockquote':
			$res .= trim(preg_replace('/^>/', '', $v));
			break;
		case 'p':
			$res .= trim($v);
		}
		$res .= "\n";
	}
	if (isset($prev)) {
		$res .= "</{$prev}>\n";
	}
	return $res;
}
